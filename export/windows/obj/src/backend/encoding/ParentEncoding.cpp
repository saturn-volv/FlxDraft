// Generated by Haxe 4.3.2
#include <hxcpp.h>

#ifndef INCLUDED_backend_encoding_ParentEncoding
#include <backend/encoding/ParentEncoding.h>
#endif
#ifndef INCLUDED_haxe_IMap
#include <haxe/IMap.h>
#endif
#ifndef INCLUDED_haxe_ds_StringMap
#include <haxe/ds/StringMap.h>
#endif

HX_LOCAL_STACK_FRAME(_hx_pos_e576e98d99922023_17_boot,"backend.encoding.ParentEncoding","boot",0x3fed5f82,"backend.encoding.ParentEncoding.boot","backend/encoding/UrlEncodedString.hx",17,0x44b4562d)
namespace backend{
namespace encoding{

void ParentEncoding_obj::__construct() { }

Dynamic ParentEncoding_obj::__CreateEmpty() { return new ParentEncoding_obj; }

void *ParentEncoding_obj::_hx_vtable = 0;

Dynamic ParentEncoding_obj::__Create(::hx::DynamicArray inArgs)
{
	::hx::ObjectPtr< ParentEncoding_obj > _hx_result = new ParentEncoding_obj();
	_hx_result->__construct();
	return _hx_result;
}

bool ParentEncoding_obj::_hx_isInstanceOf(int inClassId) {
	return inClassId==(int)0x00000001 || inClassId==(int)0x6fd56ee4;
}

 ::haxe::ds::StringMap ParentEncoding_obj::RESERVED_CHARACTERS;


ParentEncoding_obj::ParentEncoding_obj()
{
}

bool ParentEncoding_obj::__GetStatic(const ::String &inName, Dynamic &outValue, ::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"RESERVED_CHARACTERS") ) { outValue = ( RESERVED_CHARACTERS ); return true; }
	}
	return false;
}

bool ParentEncoding_obj::__SetStatic(const ::String &inName,Dynamic &ioValue,::hx::PropertyAccess inCallProp)
{
	switch(inName.length) {
	case 19:
		if (HX_FIELD_EQ(inName,"RESERVED_CHARACTERS") ) { RESERVED_CHARACTERS=ioValue.Cast<  ::haxe::ds::StringMap >(); return true; }
	}
	return false;
}

#ifdef HXCPP_SCRIPTABLE
static ::hx::StorageInfo *ParentEncoding_obj_sMemberStorageInfo = 0;
static ::hx::StaticInfo ParentEncoding_obj_sStaticStorageInfo[] = {
	{::hx::fsObject /*  ::haxe::ds::StringMap */ ,(void *) &ParentEncoding_obj::RESERVED_CHARACTERS,HX_("RESERVED_CHARACTERS",21,c4,17,35)},
	{ ::hx::fsUnknown, 0, null()}
};
#endif

static void ParentEncoding_obj_sMarkStatics(HX_MARK_PARAMS) {
	HX_MARK_MEMBER_NAME(ParentEncoding_obj::RESERVED_CHARACTERS,"RESERVED_CHARACTERS");
};

#ifdef HXCPP_VISIT_ALLOCS
static void ParentEncoding_obj_sVisitStatics(HX_VISIT_PARAMS) {
	HX_VISIT_MEMBER_NAME(ParentEncoding_obj::RESERVED_CHARACTERS,"RESERVED_CHARACTERS");
};

#endif

::hx::Class ParentEncoding_obj::__mClass;

static ::String ParentEncoding_obj_sStaticFields[] = {
	HX_("RESERVED_CHARACTERS",21,c4,17,35),
	::String(null())
};

void ParentEncoding_obj::__register()
{
	ParentEncoding_obj _hx_dummy;
	ParentEncoding_obj::_hx_vtable = *(void **)&_hx_dummy;
	::hx::Static(__mClass) = new ::hx::Class_obj();
	__mClass->mName = HX_("backend.encoding.ParentEncoding",1e,47,f0,ec);
	__mClass->mSuper = &super::__SGetClass();
	__mClass->mConstructEmpty = &__CreateEmpty;
	__mClass->mConstructArgs = &__Create;
	__mClass->mGetStaticField = &ParentEncoding_obj::__GetStatic;
	__mClass->mSetStaticField = &ParentEncoding_obj::__SetStatic;
	__mClass->mMarkFunc = ParentEncoding_obj_sMarkStatics;
	__mClass->mStatics = ::hx::Class_obj::dupFunctions(ParentEncoding_obj_sStaticFields);
	__mClass->mMembers = ::hx::Class_obj::dupFunctions(0 /* sMemberFields */);
	__mClass->mCanCast = ::hx::TCanCast< ParentEncoding_obj >;
#ifdef HXCPP_VISIT_ALLOCS
	__mClass->mVisitFunc = ParentEncoding_obj_sVisitStatics;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mMemberStorageInfo = ParentEncoding_obj_sMemberStorageInfo;
#endif
#ifdef HXCPP_SCRIPTABLE
	__mClass->mStaticStorageInfo = ParentEncoding_obj_sStaticStorageInfo;
#endif
	::hx::_hx_RegisterClass(__mClass->mName, __mClass);
}

void ParentEncoding_obj::__boot()
{
{
            		HX_BEGIN_LOCAL_FUNC_S0(::hx::LocalFunc,_hx_Closure_0) HXARGC(0)
            		 ::haxe::ds::StringMap _hx_run(){
            			HX_GC_STACKFRAME(&_hx_pos_e576e98d99922023_17_boot)
HXDLIN(  17)			 ::haxe::ds::StringMap _g =  ::haxe::ds::StringMap_obj::__alloc( HX_CTX );
HXDLIN(  17)			_g->set(HX_(" ",20,00,00,00),HX_("%20",23,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("!",21,00,00,00),HX_("%21",24,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("\"",22,00,00,00),HX_("%22",25,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("#",23,00,00,00),HX_("%23",26,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("$",24,00,00,00),HX_("%24",27,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("%",25,00,00,00),HX_("%25",28,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("&",26,00,00,00),HX_("%26",29,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("'",27,00,00,00),HX_("%27",2a,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("(",28,00,00,00),HX_("%28",2b,3f,1c,00));
HXDLIN(  17)			_g->set(HX_(")",29,00,00,00),HX_("%29",2c,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("*",2a,00,00,00),HX_("%2A",34,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("+",2b,00,00,00),HX_("%2B",35,3f,1c,00));
HXDLIN(  17)			_g->set(HX_(",",2c,00,00,00),HX_("%2C",36,3f,1c,00));
HXDLIN(  17)			_g->set(HX_("/",2f,00,00,00),HX_("%2F",39,3f,1c,00));
HXDLIN(  17)			_g->set(HX_(":",3a,00,00,00),HX_("%3A",13,40,1c,00));
HXDLIN(  17)			_g->set(HX_(";",3b,00,00,00),HX_("%3B",14,40,1c,00));
HXDLIN(  17)			_g->set(HX_("=",3d,00,00,00),HX_("%3D",16,40,1c,00));
HXDLIN(  17)			_g->set(HX_("?",3f,00,00,00),HX_("%3F",18,40,1c,00));
HXDLIN(  17)			_g->set(HX_("@",40,00,00,00),HX_("%40",e1,40,1c,00));
HXDLIN(  17)			_g->set(HX_("[",5b,00,00,00),HX_("%5B",d2,41,1c,00));
HXDLIN(  17)			_g->set(HX_("]",5d,00,00,00),HX_("%5D",d4,41,1c,00));
HXDLIN(  17)			return _g;
            		}
            		HX_END_LOCAL_FUNC0(return)

            	HX_STACKFRAME(&_hx_pos_e576e98d99922023_17_boot)
HXDLIN(  17)		RESERVED_CHARACTERS = ( ( ::haxe::ds::StringMap)( ::Dynamic(new _hx_Closure_0())()) );
            	}
}

} // end namespace backend
} // end namespace encoding
